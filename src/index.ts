import { Octokit, RestEndpointMethodTypes } from "@octokit/rest";
import { getPackageManifest } from "query-registry";
import { RequestCounter } from "./rate-limiting/request-counter";
import { TokenBucket } from "./rate-limiting/token-bucket";
import { graphql } from "@octokit/graphql";
import type {
	GraphQlQueryResponseData,
	GraphqlResponseError
} from "@octokit/graphql";
import { sleep, getAccessToken } from "./utils";
import { printHashBar, printSpacer } from "./ioFormatting";
import { generateDependencyTree } from "./outputData";
import { getDependenciesNpm, Repository, APIParameters, PackageRateLimiter, queryDependenyPyPI } from "./packageAPI";
import { DependencyGraphDependency, GraphResponse, RepoEdge, BranchManifest, UpperBranchManifest, queryGraphQL } from "./graphQLAPI"

var Map = require("es6-map");

// //Ratelimiter is a POJO that contains a TokenBuckets and RequestCounters for each API source.
// export type RateLimiter = {
// 	// Github: {
// 	// 	tokenBucket: TokenBucket;
// 	// 	reqCounter: RequestCounter;
// 	// };
// }

//Declaring a type alias for representing a repository in order to avoid this octokit mess
type OctokitRepository =
	RestEndpointMethodTypes["repos"]["listForOrg"]["response"]["data"][0];

// Defining the GitHub API client.
let octokit: Octokit;

// gets repos that have package.json, returns list of repo objects 
function getPkgJSONRepos(response: GraphResponse) {
	const PKG_JSON = "package.json";
	const allRepos: RepoEdge[] = response?.organization?.repositories?.edges;
	let filteredRepos: BranchManifest[] = []
	for (const repo of allRepos) {
		console.log(repo);
		const ref = repo.node.mainBranch ? repo.node.mainBranch : repo.node.masterBranch;
		if (ref == null) {
			continue
		}

		const depGraphManifests = ref.repository.dependencyGraphManifests;
		const files: any[] = depGraphManifests.edges;

		//This requires files to be sorted by depth, shallowest first
		for (const file of files) {
			const blobPath = file.node.blobPath;
			if (blobPath.endsWith(PKG_JSON)) {
				filteredRepos.push(ref)
				break
			}

		}
	}
	return filteredRepos
}

// Params: blobPath: name of blobPath string, deps: dependencies list from blobPath. 
// returns object with { blob path: <file name eg. /blah/package.json>,  dependencies: <list of deps from blobpath file> }
// get dependencies of a repo obj, used by function getAllRepoDeps(repoList)
// returns object with repo name and list of blob paths ending with package.json and blob path's dependencies
function getRepoDependencies(repo: BranchManifest) {
	// add more extensions in the future
	const extensions: string[] = ["package.json"];


	function blobPathDeps(subPath: string, blobPath: string, version: string, deps: DependencyGraphDependency[]) {
		return {
			subPath: subPath,
			blobPath: blobPath,
			version: version,
			dependencies: deps
		}
	}

	let repoDepObj: {
		manifest: UpperBranchManifest,
		blobPathDepsList: ReturnType<typeof blobPathDeps>[]
	} = {
		manifest: repo.repository as UpperBranchManifest,
		blobPathDepsList: []
	}

	const depGraphManifests = repo.repository.dependencyGraphManifests
	const files = depGraphManifests.edges
	let index = 0
	// iterate through all files in repo to find the ones with package.json
	for (const file of files) {
		const blobPath = file.node.blobPath;
		const subPath = depGraphManifests.nodes[index].filename
		index += 1;
		for (const ext of extensions) {
			// check blobpath ends with extension 
			if (blobPath.endsWith(ext)) {
				console.log(blobPath + ", " + subPath)
				const version = ""//file.node.version
				const depCount = file.node.dependencies.totalCount
				if (depCount > 0) {
					const dependencies = file.node.dependencies.nodes
					const blobPathDep = blobPathDeps(subPath, blobPath, version, dependencies)
					repoDepObj.blobPathDepsList.push(blobPathDep)
				}
				else {
					// currently includes package.json files with no dependencies
					const blobPathDep = blobPathDeps(subPath, blobPath, version, [])
					repoDepObj.blobPathDepsList.push(blobPathDep)
				}

			}
		}
	}
	return repoDepObj
}

// get dependencies of all repos in repoList, repolist: list of repo objects
// repoList generated by getPkgJSONRepos()
function getAllRepoDeps(repoList: BranchManifest[]) {
	let all_dependencies: ReturnType<typeof getRepoDependencies>[] = []
	for (const repo of repoList) {
		const deps = getRepoDependencies(repo)
		all_dependencies.push(deps)
	}
	return all_dependencies
}

function mergeDependenciesLists(repos: Repository[]): string[] {
	let deps = new Set<string>();

	for (const repo of repos) {
		for (const [name, version] of repo.dependencies) {
			deps.add(name);
		}
	}

	return Array.from(deps.values());
}

//Main function
async function main() {
	const accessToken = getAccessToken();

	const rateLimiter: PackageRateLimiter = {
		npm: { tokenBucket: new TokenBucket(1000, APIParameters.npm.rateLimit, APIParameters.npm.intialTokens) },
		pypi: { tokenBucket: new TokenBucket(1000, APIParameters.pypi.rateLimit, APIParameters.pypi.intialTokens) },
	};

	//TEST

	console.log(await queryDependenyPyPI("black", rateLimiter))

	return

	const startTime = Date.now();

	// ==== START: Extracting dependencies from Github graphql response === //

	//TODO: make sure following loop can run concurrently
	//let allDepPromises: Promise<Repository>[] = [];


	const allDeps: Repository[] = [] //await Promise.all(allDepPromises);

	let repoCursor = null;
	let hasNextPage = false;
	do {
		const response = await queryGraphQL(accessToken, repoCursor) as GraphResponse;

		const repoList = getPkgJSONRepos(response as GraphResponse);
		console.log(repoList);
		const allRepoDeps = getAllRepoDeps(repoList);
		console.log(JSON.stringify(allRepoDeps, null, " "));

		for (const repo of allRepoDeps) {
			const name = repo.manifest.name
			for (const subRepo of repo.blobPathDepsList) {
				let deps: Map<string, string> = new Map();

				for (const dep of subRepo.dependencies) {
					deps.set(dep.packageName, dep.requirements)
				}

				let rep: Repository = {
					name: name + "(" + subRepo.subPath + ")",
					version: subRepo.version,
					link: repo.manifest.url,
					isArchived: repo.manifest.isArchived,
					dependencies: deps
				}

				allDeps.push(rep)
			}
		}

		hasNextPage = response?.organization?.repositories?.pageInfo?.hasNextPage
		if (hasNextPage) {
			repoCursor = response?.organization?.repositories?.pageInfo?.endCursor
		}
	} while (hasNextPage)

	// allDeps: list of dependencies to be given to npm 
	const npmDeps = mergeDependenciesLists(allDeps);

	const depDataMap = await getDependenciesNpm(npmDeps, rateLimiter);

	//Wait for all requests to finish
	console.log("Waiting for all requests to finish");
	await Promise.all([
		//rateLimiter.Github.tokenBucket.waitForShorterQueue(1000),
		rateLimiter.npm.tokenBucket.waitForShorterQueue(1000),
	]);

	//Print req counters report
	const endTime = Date.now();
	console.log(`Total time ${endTime - startTime}`)

	//At this point the bucket queue will be empty, but there might still be some requests in flight.
	await sleep(3000);

	//printRateLimitInfo(startTime, endTime, rateLimiter);
	console.log(JSON.stringify(generateDependencyTree(allDeps, depDataMap)));
}

main();
