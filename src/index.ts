import { Octokit, RestEndpointMethodTypes } from "@octokit/rest";
import { TokenBucket } from "./rate-limiting/token-bucket";
import { getAccessToken, loadConfig, writeFile } from "./utils";
import { generateDependencyTree } from "./outputData";
import { getDependenciesNpm, getDependenciesPyPI, Repository, APIParameters, PackageRateLimiter, queryDependenyPyPI } from "./packageAPI";
import { DependencyGraphDependency, GraphResponse, RepoEdge, BranchManifest, UpperBranchManifest, queryGraphQL } from "./graphQLAPI"

//var Map = require("es6-map");

//Declaring a type alias for representing a repository in order to avoid this octokit mess
type OctokitRepository =
	RestEndpointMethodTypes["repos"]["listForOrg"]["response"]["data"][0];

// Defining the GitHub API client.
let octokit: Octokit;

// returns list of repo objects 
function getRepos(response: GraphResponse) {
	const allRepos: RepoEdge[] = response?.organization?.repositories?.edges;
	let filteredRepos: BranchManifest[] = []
	for (const repo of allRepos) {
		//console.log(repo);
		const ref = repo.node.mainBranch ? repo.node.mainBranch : repo.node.masterBranch;
		if (ref == null) {
			continue
		}

		filteredRepos.push(ref)
	}
	return filteredRepos
}

// get dependencies of a repo obj, used by function getAllRepoDeps(repoList)
// returns object with repo name and list of blob paths ending with package.json and blob path's dependencies
function getRepoDependencies(repo: BranchManifest) {
	const packageManagers = [
		{ name: "NPM", extensions: ["package.json"] },
		{ name: "PYPI", extensions: ["requirements.txt"] },
	]

	function blobPathDeps(subPath: string, blobPath: string, version: string, deps: DependencyGraphDependency[]) {
		return { subPath: subPath, blobPath: blobPath, version: version, dependencies: deps }
	}

	let repoDepObj: {
		manifest: UpperBranchManifest, packageMap: Map<string, ReturnType<typeof blobPathDeps>[]>
	} = { manifest: repo.repository as UpperBranchManifest, packageMap: null }

	repoDepObj.packageMap = new Map()

	const depGraphManifests = repo.repository.dependencyGraphManifests
	const files = depGraphManifests.edges
	let index = 0
	// iterate through all files in repo to find the ones with package.json
	for (const file of files) {
		const blobPath = file.node.blobPath;
		const subPath = depGraphManifests.nodes[index].filename
		index += 1;
		for (const packageManager of packageManagers) {			
			for (const ext of packageManager.extensions) {
				// check path ends with extension 
				if (subPath.endsWith(ext)) {
					console.log(blobPath + ", " + subPath)
					const version = ""//file.node.version
					const depCount = file.node.dependencies.totalCount

					if(!repoDepObj.packageMap.has(packageManager.name)){
						repoDepObj.packageMap.set(packageManager.name, [])
					}

					if (depCount > 0) {
						const dependencies = file.node.dependencies.nodes
						const blobPathDep = blobPathDeps(subPath, blobPath, version, dependencies)
						repoDepObj.packageMap.get(packageManager.name).push(blobPathDep)
					} else {
						// currently includes package.json files with no dependencies
						const blobPathDep = blobPathDeps(subPath, blobPath, version, [])
						repoDepObj.packageMap.get(packageManager.name).push(blobPathDep)
					}
				}
			}
		}
	}

	return repoDepObj
}

// get dependencies of all repos in repoList, repolist: list of repo objects
// repoList generated by getPkgJSONRepos()
function getAllRepoDeps(repoList: BranchManifest[]) {
	let all_dependencies: ReturnType<typeof getRepoDependencies>[] = []
	for (const repo of repoList) {
		const deps = getRepoDependencies(repo)
		if(deps.packageMap.size > 0){
			all_dependencies.push(deps)
		}
	}
	return all_dependencies
}

function mergeDependenciesLists(managerRepos: Map<string, Repository[]>): Map<string, string[]> {
	let deps: Map<string, Set<string>> = new Map()

	for (const [packageManager, repos] of managerRepos) {
		console.log(packageManager)
		for(const repo of repos){
			for (const [name, version] of repo.dependencies) {
				console.log("\t" + name)
				if(!deps.has(packageManager)){ deps.set(packageManager, new Set()) }
				deps.get(packageManager).add(name);
			}
		}
	}

	let managerDeps: Map<string, string[]> = new Map()

	for(const [key, value] of deps){
		managerDeps.set(key, Array.from(value.values()))
	}

	return managerDeps
}

//Main function
async function main() {
	const accessToken = getAccessToken()
	const config = loadConfig()

	console.log("Configuration:")
	console.log(config)
	console.log(config.targetOrganisation)

	const rateLimiter: PackageRateLimiter = {
		npm: { tokenBucket: new TokenBucket(1000, APIParameters.npm.rateLimit, APIParameters.npm.intialTokens) },
		pypi: { tokenBucket: new TokenBucket(1000, APIParameters.pypi.rateLimit, APIParameters.pypi.intialTokens) },
	};

	const startTime = Date.now();

	// ==== START: Extracting dependencies from Github graphql response === //

	const allDeps: Map<string, Repository[]> = new Map()

	let repoCursor = null;
	let hasNextPage = false;
	do {
		const response = await queryGraphQL(config.targetOrganisation, accessToken, repoCursor) as GraphResponse;

		for (const repo of response?.organization?.repositories?.edges) {
			const ref = repo.node.mainBranch ? repo.node.mainBranch : repo.node.masterBranch;
			if (ref == null) {
				continue
			}

			const depGraphManifests = ref.repository.dependencyGraphManifests;
			const files: any[] = depGraphManifests.edges;

			console.log(ref.repository.name)

			//This requires files to be sorted by depth, shallowest first
			for (const file of files) {
				const blobPath = file.node.blobPath;
				console.log(blobPath)
			}
		}

		const repoList = getRepos(response);
		const allRepoDeps = getAllRepoDeps(repoList);

		for (const repo of allRepoDeps) {
			const name = repo.manifest.name

			for(const [packageManager, depList] of repo.packageMap){
				for (const subRepo of depList) {
					let deps: Map<string, string> = new Map();

					for (const dep of subRepo.dependencies) {
						deps.set(dep.packageName, dep.requirements)
					}

					let rep: Repository = {
						name: name + "(" + subRepo.subPath + ")",
						version: subRepo.version,
						link: repo.manifest.url,
						isArchived: repo.manifest.isArchived,
						dependencies: deps
					}

					if(!allDeps.has(packageManager)){
						allDeps.set(packageManager, [])
					}
					allDeps.get(packageManager).push(rep)
				}
			}
		}

		hasNextPage = response?.organization?.repositories?.pageInfo?.hasNextPage
		if (hasNextPage) {
			repoCursor = response?.organization?.repositories?.pageInfo?.endCursor
		}
	} while (hasNextPage)

	// allDeps: list of dependencies to be given to package APIs
	const packageDeps = mergeDependenciesLists(allDeps);

	const npmDepDataMap = packageDeps.has("NPM") ? await getDependenciesNpm(packageDeps.get("NPM"), rateLimiter) : null;
	console.log("Finished npm. Size: " + npmDepDataMap.size)
	const pypiDepDataMap = packageDeps.has("PYPI") ? await getDependenciesPyPI(packageDeps.get("PYPI"), rateLimiter) : null;
	console.log("Finished PyPI. Size: " + pypiDepDataMap.size)

	//Wait for all requests to finish
	console.log("Waiting for all requests to finish");
	await Promise.all([
		//rateLimiter.Github.tokenBucket.waitForShorterQueue(100),
		rateLimiter.npm.tokenBucket.waitForShorterQueue(100),
	]);

	//Print the total time
	const endTime = Date.now();
	console.log("Total time: " + ((endTime - startTime) / 1000).toString())

	let jsonResult: string = ""

	jsonResult += "{"
	jsonResult += "\"npm\": ["
	jsonResult += !allDeps.has("NPM") ? "" : generateDependencyTree(allDeps.get("NPM"), npmDepDataMap)
	jsonResult += "], "
	jsonResult += "\"PyPI\": ["
	jsonResult += !allDeps.has("PYPI") ? "" : generateDependencyTree(allDeps.get("PYPI"), pypiDepDataMap)
	jsonResult += "]"
	jsonResult += "}"

	console.log(jsonResult)
	writeFile("cachedData.json", jsonResult);
}

main();
